<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo-asset-image插件无法正确识别图片路径</title>
    <url>/2022/01/26/Hexo-asset-image%E6%8F%92%E4%BB%B6%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><code>问题背景</code><br>路径后面会多一层域名的.work<br>比如域名为yuxiang.work,图片会被链接到下面的路径<br><img src="http://yuxiang.work/2022/01/26/Hexo-asset-image%E6%8F%92%E4%BB%B6%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220126180401.png" alt="微信截图_20220126180401.png"></p>
<p><code>解决方案</code><br>修改插件的源码<code>index.js</code><br><img src="http://yuxiang.work/2022/01/26/Hexo-asset-image%E6%8F%92%E4%BB%B6%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220126180652.png" alt="微信截图_20220126180652.png"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用总结</title>
    <url>/2022/01/24/hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><code>hexo安装</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p><code>hexo部署</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成静态文章</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署文章</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><code>发布文章</code></p>
<p><strong>在发布之前了解下默认的3种布局(layout)</strong></p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
<td>发布</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
<td>另起一页</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
<td>草稿</td>
</tr>
</tbody></table>
<p><strong>可以修改3中布局模版达到定制效果</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发布命令</span></span><br><span class="line">hexo new [<span class="type">layout</span>] &lt;title&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3种发布命令</span></span><br><span class="line">hexo new page test</span><br><span class="line">hexo new draft test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用的是post的模版</span></span><br><span class="line">hexo new post test</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hexo new test（新建文章 名test）</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#草稿预览：</span></span><br><span class="line">hexo server -<span class="literal">-draft</span></span><br><span class="line"><span class="comment">#草稿的发布：</span></span><br><span class="line">hexo publish draft test</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>js之Data对象使用</title>
    <url>/2022/02/08/js%E4%B9%8BData%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）</span><br></pre></td></tr></table></figure>

<h2 id="普通函数用法"><a href="#普通函数用法" class="headerlink" title="普通函数用法"></a>普通函数用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个代表当前时间的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>()); <span class="comment">// Wed Feb 09 2022 15:38:52 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// 即使带了参数也是返回当前时间, 参数个数没有影响</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// Wed Feb 09 2022 15:40:11 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>(<span class="number">2000</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h2 id="构造函数用法"><a href="#构造函数用法" class="headerlink" title="构造函数用法"></a>构造函数用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的UTC时间</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 2022-02-09T07:35:37.335Z</span></span><br><span class="line"><span class="comment">// 时间戳转为字符串格式</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>); <span class="comment">// 1970-01-01T00:00:00.000Z</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1644394635720</span>); <span class="comment">// 2022-02-09T08:17:15.720Z</span></span><br><span class="line"><span class="comment">// 时间戳为负数则代表1970之前的时间</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(-<span class="number">1644394635720</span>); <span class="comment">// 1917-11-22T15:42:44.280Z </span></span><br><span class="line"><span class="comment">// 当前时间转化为时间戳（单位：ms）</span></span><br><span class="line"><span class="keyword">let</span> now1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 1644394635720</span></span><br><span class="line"><span class="comment">// 指定字符串格式的时间转换为时间戳</span></span><br><span class="line"><span class="keyword">let</span> now2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2022-02-09T07:35:37.335Z&#x27;</span>).getTime(); <span class="comment">// 1644392137335</span></span><br></pre></td></tr></table></figure>

<p><strong>只要能被Date.parse()解析就可以当成字符串传入new Date()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2022-02-08T16:00:00.000Z</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2022-2-9&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2022/2/9&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2/9/2022&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2022-FEB-9&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;FEB, 9, 2022&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;FEB 9, 2022&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;February, 9, 2022&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;February 9, 2022&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;9 Feb 2022&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;9, February, 2022&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>new Date()多个参数</strong></p>
<blockquote>
<p><code>new Date(year, month, date, hours, minutes, seconds, ms)</code><br>使用当前时区中的给定组件创建日期。只有<code>前两个参数是必须的</code>。<br>也就是说年和月是必须的，最少两个参数，否则被识别为时间戳了。<br>$ new Date(2022) // 1970-01-01T00:00:02.022Z<br>$ new Date(2022, 2) // 2022-02-28T16:00:00.000Z<br>year 必须是四位数：2013 是合法的，98 是不合法的。<br>month 计数从 0（一月）开始，到 11（十二月）结束。<br>date 是当月的具体某一天，如果缺失，则为默认值 1。<br>如果 hours/minutes/seconds/ms 缺失，则均为默认值 0。</p>
</blockquote>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><strong>Date.parse()</strong></p>
<blockquote>
<p><code>Date.parse()</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数.<br>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的Z表示时区。</p>
</blockquote>
<p><strong>Date.now()</strong></p>
<blockquote>
<p><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。<br>$ console.log(Date.now()); // 1644399418450</p>
</blockquote>
<p><strong>Date.UTC()</strong></p>
<blockquote>
<p><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。<br>// 格式<br>Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])<br>// 用法<br>Date.UTC(2011, 0, 1, 2, 3, 4, 567)<br>// 1293847384567</p>
</blockquote>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>回车和换行的历史</title>
    <url>/2023/02/27/%E5%9B%9E%E8%BD%A6%E5%92%8C%E6%8D%A2%E8%A1%8C%E7%9A%84%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<h4 id="命名历史"><a href="#命名历史" class="headerlink" title="命名历史"></a>命名历史</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。</span><br><span class="line">但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。</span><br><span class="line">要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</span><br><span class="line">于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做&quot;回车&quot;，告诉打字机把打印头定位在左边界；另一个叫做&quot;换行&quot;，告诉打字机把纸向下移一行。</span><br><span class="line">这就是&quot;换行&quot;和&quot;回车&quot;的来历，从它们的英语名字上也可以看出一二。</span><br><span class="line"></span><br><span class="line">&quot;回车&quot;（carriage return）和&quot;换行&quot;（line feed） 是来源机械英文打字机</span><br><span class="line">&quot;车&quot;指的是纸车,带着纸一起左右移动的模块.</span><br><span class="line">当开始打第一个字之前，要把纸车拉到最右边，上紧弹簧.随着打字，弹簧把纸车拉回去.每当打完一行后，纸车就完全收回去了.所以叫回车.</span><br><span class="line">换行的概念就是:打字机左边有个&quot;把手&quot;,往下扳动一下,纸会上移一行.</span><br></pre></td></tr></table></figure>

<h4 id="不同系统中的差异"><a href="#不同系统中的差异" class="headerlink" title="不同系统中的差异"></a>不同系统中的差异</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">后来，计算机发明了，这两个概念也就被般到了计算机上。</span><br><span class="line">那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。</span><br><span class="line">于是，就出现了分歧。</span><br><span class="line"></span><br><span class="line">Unix系统: \n</span><br><span class="line">Windows: \r\n</span><br><span class="line">Mac: \r</span><br></pre></td></tr></table></figure>

<p><a href="http://www.ruanyifeng.com/blog/2006/04/post_213.html">引用文章</a></p>
<h4 id="ChatGPT的回答"><a href="#ChatGPT的回答" class="headerlink" title="ChatGPT的回答"></a>ChatGPT的回答</h4><p><code>我：Why were carriage returns and line feeds created?</code></p>
<p><code>ChatGPT：</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Carriage returns and line feeds were created as a means of controlling how text was displayed on early computer systems and printers.</span><br><span class="line"></span><br><span class="line">In the early days of computing, text was typically printed on teletype machines, which used a combination of mechanical and electrical systems to print characters on paper. These machines used a roll of paper that was fed through the machine, with characters being printed on the paper one at a time.</span><br><span class="line"></span><br><span class="line">To control the position of the printing head, teletype machines used two separate control codes: a carriage return (CR) and a line feed (LF).</span><br><span class="line"></span><br><span class="line">A carriage return (CR) code instructs the machine to move the printing head all the way to the left margin of the paper. This was necessary because the printing head would typically be positioned at the right side of the paper after printing a line of text, so a carriage return was necessary to reset the position of the head.</span><br><span class="line"></span><br><span class="line">A line feed (LF) code instructs the machine to move the paper up by one line, so that the next line of text can be printed. This was necessary because the paper on a teletype machine was fed vertically through the machine, so moving the paper up by one line was necessary to print on the next line.</span><br><span class="line"></span><br><span class="line">Today, carriage returns and line feeds are still used in some contexts, such as in programming languages or when working with text files in certain operating systems. However, the way they are used has evolved over time and varies depending on the specific context.</span><br></pre></td></tr></table></figure>

<p><code>我：Why is the carriage return or line feed at the end of the text different in different operating systems?</code></p>
<p><code>ChatGPT：</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The reason why carriage return or line feed at the end of text is different in different operating systems is rooted in historical differences in how these operating systems handled text and line endings.</span><br><span class="line"></span><br><span class="line">In Unix and Unix-like operating systems, such as Linux and macOS, a line feed (LF) character is used to mark the end of a line of text. This convention dates back to the early days of Unix, when it was developed as a text-based operating system. In Unix, files are stored as a sequence of lines, with each line terminated by a single LF character. This convention is also used in programming languages that were developed on Unix, such as C and its derivatives.</span><br><span class="line"></span><br><span class="line">In contrast, in early versions of Microsoft Windows and MS-DOS, a carriage return (CR) followed by a line feed (LF) sequence is used to mark the end of a line of text. This convention goes back to the days of typewriters and teletype machines, which used both the CR and LF codes to signal the end of a line. When Microsoft developed its early operating systems, it inherited this convention.</span><br><span class="line"></span><br><span class="line">The difference in line endings between Unix-like systems and Windows can cause issues when transferring files between systems. For example, if a text file created on a Windows machine is opened on a Unix system, the presence of the CR character may cause the lines to appear incorrectly. Similarly, if a text file created on a Unix system is opened on a Windows machine, the lack of the CR character may cause the lines to appear incorrectly.</span><br><span class="line"></span><br><span class="line">To avoid these issues, many text editors and programming tools now have the ability to automatically convert line endings between Unix and Windows formats, or to handle both formats correctly.</span><br></pre></td></tr></table></figure>

<p><code>我：Why is the end of the mac operating system a carriage return?</code></p>
<p><code>ChatGPT：</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Historically, Mac OS (now known as macOS) used a carriage return (CR) character to mark the end of a line of text. This convention dates back to the early days of the Macintosh computer, which was first introduced in 1984.</span><br><span class="line"></span><br><span class="line">The Macintosh was designed to be a user-friendly computer that was accessible to non-technical users, and part of this design philosophy was reflected in the way it handled text. The original Macintosh operating system, known as System 1, used a simple, intuitive interface for editing text, which involved using the return key to create new lines of text.</span><br><span class="line"></span><br><span class="line">To achieve this behavior, the Macintosh operating system used a single CR character to mark the end of each line of text. This was a departure from the convention used in other operating systems of the time, such as Unix and MS-DOS, which used a combination of a CR and a line feed (LF) character to mark the end of a line.</span><br><span class="line"></span><br><span class="line">The use of a single CR character on the Macintosh made it easier for users to create and edit text, since they could simply press the return key to start a new line. However, this convention also made it difficult to exchange text files with other operating systems, which may expect a different line ending convention.</span><br><span class="line"></span><br><span class="line">Today, macOS still uses a single CR character as the default line ending convention for text files created on the system. However, most modern text editors and programming tools are able to handle multiple line ending conventions, including the use of both CR and LF characters, to ensure compatibility with other operating systems.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机趣闻</tag>
      </tags>
  </entry>
  <entry>
    <title>源码、反码、补码</title>
    <url>/2023/02/27/%E6%BA%90%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
</search>
